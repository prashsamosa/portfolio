---
import slugify from "slugify";
import Layout from "@/layouts/Layout.astro";
import AboutSection from "@/components/Sections/AboutSection.astro";
import ExperienceSection from "@/components/Sections/ExperienceSection.astro";
import EducationSection from "@/components/Sections/EducationSection.astro";
import SkillsSection from "@/components/Sections/SkillsSection.astro";
import ProjectsSection from "@/components/Sections/ProjectsSection.astro";
import PostsSection from "@/components/Sections/PostsSection.astro";

const SECTION_CONFIG = {
  about: {
    component: AboutSection,
    title: "About",
    order: 1,
  },
  stack: {
    component: SkillsSection,
    title: "Stack",
    order: 2,
  },
  projects: {
    component: ProjectsSection,
    title: "Projects",
    order: 3,
  },
  education: {
    component: EducationSection,
    title: "Education",
    order: 4,
  },
  experience: {
    component: ExperienceSection,
    title: "Experience",
    order: 5,
  },
  posts: {
    component: PostsSection,
    title: "Posts",
    order: 6,
  },
} as const;

const PERSONAL_INFO = {
  name: "Prashant Bhardwaj",
  title: "dev",
  description: "trying to do better",
} as const;

const sections = Object.entries(SECTION_CONFIG).sort(
  ([, a], [, b]) => a.order - b.order,
);

const navItems = sections.map(([key]) => key);
---

<Layout
  isHome={true}
  title={PERSONAL_INFO.name}
  subtitle={PERSONAL_INFO.title}
  details={PERSONAL_INFO.description}
  navItems={navItems}
>
  {
    sections.map(([sectionKey, sectionConfig]) => {
      const SectionComponent = sectionConfig.component;
      const sectionId = slugify(sectionKey, { lower: true });

      return (
        <section
          id={sectionId}
          class="portfolio-section"
          data-section={sectionKey}
        >
          <h1 class="section-title">{sectionConfig.title}</h1>
          <div class="section-content">
            <SectionComponent />
          </div>
        </section>
      );
    })
  }
</Layout>

<style>
  .portfolio-section {
    padding-bottom: 6rem;
    transition: opacity 500ms ease-in-out;
  }

  .section-title {
    font-size: 1.7rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 2.5rem;
    color: var(--color-foreground, currentColor);
  }

  .section-content {
    position: relative;
  }

  h2 {
    font-size: 1rem;
    font-weight: 600;
    margin-bottom: 1rem;
  }

  @media (min-width: 1024px) {
    .portfolio-section {
      scroll-margin-top: 6rem;
      padding-top: 0;
      opacity: 0.5;
    }

    .portfolio-section:focus-within,
    .portfolio-section.section-focus {
      opacity: 1;
    }

    .portfolio-section:last-of-type {
      padding-bottom: 0;
    }

    .portfolio-section:focus-visible {
      outline: 2px solid var(--color-ring, #ffffff);
      outline-offset: 4px;
      border-radius: 4px;
    }
  }

  @media (prefers-reduced-motion: reduce) {
    .portfolio-section {
      transition: none;
    }
  }

  @media print {
    .portfolio-section {
      break-inside: avoid;
      opacity: 1 !important;
      padding-bottom: 2rem;
    }
  }
</style>

<script>
  // Initial hash cleanup
  (function () {
    const referrer = document.referrer;
    const currentDomain = window.location.hostname;
    const isExternalReferrer = !referrer || !referrer.includes(currentDomain);

    if (window.location.hash && isExternalReferrer) {
      history.replaceState(
        null,
        "",
        window.location.pathname + window.location.search,
      );
    }
  })();

  // Portfolio Layout Manager
  class PortfolioLayoutManager {
    private resizeObserver?: ResizeObserver;
    private intersectionObserver?: IntersectionObserver;
    private readonly DESKTOP_BREAKPOINT = 1024;
    private readonly DEBOUNCE_DELAY = 300;
    private hasUserInteracted = false;

    init(): void {
      this.alignLastSection();
      this.observeVisibility();
      this.setupEventListeners();
      this.setupUserInteractionDetection();
    }

    private setupUserInteractionDetection(): void {
      const eventTypes = ["scroll", "click", "keydown", "touchstart"];

      const handler = (): void => {
        this.hasUserInteracted = true;
        // Remove all event listeners
        eventTypes.forEach((eventType) => {
          document.removeEventListener(eventType, handler);
        });
      };

      // Add event listeners
      eventTypes.forEach((eventType) => {
        document.addEventListener(eventType, handler, { once: true });
      });

      // Fallback timeout
      setTimeout(() => {
        this.hasUserInteracted = true;
      }, 2000);
    }

    private setupEventListeners(): void {
      if (typeof ResizeObserver !== "undefined") {
        this.resizeObserver = new ResizeObserver(
          this.debounce(() => this.handleResize(), this.DEBOUNCE_DELAY),
        );
        this.resizeObserver.observe(document.body);
      } else {
        window.addEventListener(
          "resize",
          this.debounce(() => this.handleResize(), this.DEBOUNCE_DELAY),
        );
      }
    }

    private handleResize(): void {
      this.alignLastSection();
    }

    private alignLastSection(): void {
      const lastSection = document.querySelector(
        ".portfolio-section:last-of-type",
      ) as HTMLElement;
      const header = document.querySelector("header") as HTMLElement;
      const footer = document.querySelector("footer") as HTMLElement;

      if (!lastSection || !header) return;

      if (window.innerWidth < this.DESKTOP_BREAKPOINT) {
        lastSection.style.paddingBottom = "";
        if (footer) {
          footer.style.position = "";
          footer.style.marginTop = "";
        }
        return;
      }

      try {
        const headerStyle = getComputedStyle(header);
        const headerPadding =
          parseInt(headerStyle.paddingTop || "0", 10) +
          parseInt(headerStyle.paddingBottom || "0", 10);

        const lastSectionStyle = getComputedStyle(lastSection);
        const lastSectionHeight =
          parseInt(lastSectionStyle.height || "0", 10) -
          parseInt(lastSectionStyle.paddingBottom || "0", 10);

        const requiredPadding = Math.max(
          0,
          window.innerHeight - headerPadding - lastSectionHeight,
        );

        lastSection.style.paddingBottom = `${requiredPadding}px`;

        if (footer) {
          const footerHeight = parseInt(
            getComputedStyle(footer).height || "0",
            10,
          );
          const shouldFloat = requiredPadding >= footerHeight;

          footer.style.position = shouldFloat ? "absolute" : "relative";
          footer.style.marginTop = shouldFloat ? "0" : "6rem";
        }
      } catch (error) {
        console.warn("Error aligning last section:", error);
      }
    }

    private observeVisibility(): void {
      if (typeof IntersectionObserver === "undefined") return;

      const sections = document.querySelectorAll(".portfolio-section");

      this.intersectionObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            const section = entry.target as HTMLElement;

            if (entry.isIntersecting) {
              section.classList.add("section-focus");
              const sectionId = section.id;
              if (
                sectionId &&
                this.hasUserInteracted &&
                window.location.hash !== `#${sectionId}`
              ) {
                history.replaceState(null, "", `#${sectionId}`);
              }
            } else {
              section.classList.remove("section-focus");
            }
          });
        },
        {
          threshold: 0.3,
          rootMargin: "-10% 0px -10% 0px",
        },
      );

      sections.forEach((section) => {
        if (this.intersectionObserver) {
          this.intersectionObserver.observe(section);
        }
      });
    }

    private debounce<T extends (...args: any[]) => void>(
      func: T,
      wait: number,
    ): (...args: Parameters<T>) => void {
      let timeout: ReturnType<typeof setTimeout>;
      return (...args: Parameters<T>) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }

    destroy(): void {
      if (this.resizeObserver) {
        this.resizeObserver.disconnect();
      }
      if (this.intersectionObserver) {
        this.intersectionObserver.disconnect();
      }
    }
  }

  // Initialize the layout manager
  const layoutManager = new PortfolioLayoutManager();

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => layoutManager.init());
  } else {
    layoutManager.init();
  }

  window.addEventListener("beforeunload", () => layoutManager.destroy());
</script>
